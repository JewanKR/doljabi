// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v6.32.1
// source: badukboard.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "badukboardproto";

/** 바둑판 턴 정보 */
export enum Color {
  COLOR_BLACK = 0,
  COLOR_WHITE = 1,
  COLOR_FREE = 2,
  COLOR_ERROR = 3,
  UNRECOGNIZED = -1,
}

export function colorFromJSON(object: any): Color {
  switch (object) {
    case 0:
    case "COLOR_BLACK":
      return Color.COLOR_BLACK;
    case 1:
    case "COLOR_WHITE":
      return Color.COLOR_WHITE;
    case 2:
    case "COLOR_FREE":
      return Color.COLOR_FREE;
    case 3:
    case "COLOR_ERROR":
      return Color.COLOR_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Color.UNRECOGNIZED;
  }
}

export function colorToJSON(object: Color): string {
  switch (object) {
    case Color.COLOR_BLACK:
      return "COLOR_BLACK";
    case Color.COLOR_WHITE:
      return "COLOR_WHITE";
    case Color.COLOR_FREE:
      return "COLOR_FREE";
    case Color.COLOR_ERROR:
      return "COLOR_ERROR";
    case Color.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** 바둑, 오목 비트보드를 그대로 직렬화한 상태 */
export interface BadukBoardState {
  black: bigint[];
  white: bigint[];
}

/** 플레이어 시간 정보 */
export interface PlayerTimeInfo {
  mainTime: bigint;
  fischerTime: bigint;
  remainingOvertime: number;
  overtime: bigint;
}

/** 보드 시간 턴 정보 */
export interface GameState {
  board: BadukBoardState | undefined;
  blackTime?: PlayerTimeInfo | undefined;
  whiteTime?: PlayerTimeInfo | undefined;
}

export interface ChaksuRequest {
  coordinate: number;
}

export interface DrawOfferRequest {
}

export interface ResignRequest {
}

export interface PassTurnRequest {
}

export interface GameStartRequest {
}

export interface ClientToServerRequest {
  sessionKey: string;
  coordinate?: ChaksuRequest | undefined;
  resign?: ResignRequest | undefined;
  drawOffer?: DrawOfferRequest | undefined;
  passTurn?: PassTurnRequest | undefined;
  gamestart?: GameStartRequest | undefined;
}

export interface ChaksuResponse {
  success: boolean;
}

export interface ResignResponse {
}

export interface DrawOfferResponse {
  userName: string;
}

export interface PassTurnResponse {
}

export interface UserInfo {
  userName: string;
  rating: number;
}

export interface GameStartResponse {
}

export interface UsersInfo {
  black?: UserInfo | undefined;
  white?: UserInfo | undefined;
}

export interface ServerToClientResponse {
  responseType: boolean;
  turn: Color;
  theWinner?: Color | undefined;
  gameState?: GameState | undefined;
  usersInfo?: UsersInfo | undefined;
  coordinate?: ChaksuResponse | undefined;
  resign?: ResignResponse | undefined;
  drawOffer?: DrawOfferResponse | undefined;
  passTurn?: PassTurnResponse | undefined;
  gameStart?: GameStartResponse | undefined;
}

function createBaseBadukBoardState(): BadukBoardState {
  return { black: [], white: [] };
}

export const BadukBoardState: MessageFns<BadukBoardState> = {
  encode(message: BadukBoardState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.black) {
      if (BigInt.asUintN(64, v!) !== v!) {
        throw new globalThis.Error("value provided for field v! of type fixed64 too large");
      }
      writer.uint32(9).fixed64(v!);
    }
    for (const v of message.white) {
      if (BigInt.asUintN(64, v!) !== v!) {
        throw new globalThis.Error("value provided for field v! of type fixed64 too large");
      }
      writer.uint32(17).fixed64(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BadukBoardState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBadukBoardState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 9) {
            message.black.push(reader.fixed64() as bigint);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.black.push(reader.fixed64() as bigint);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag === 17) {
            message.white.push(reader.fixed64() as bigint);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.white.push(reader.fixed64() as bigint);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BadukBoardState {
    return {
      black: globalThis.Array.isArray(object?.black) ? object.black.map((e: any) => BigInt(e)) : [],
      white: globalThis.Array.isArray(object?.white) ? object.white.map((e: any) => BigInt(e)) : [],
    };
  },

  toJSON(message: BadukBoardState): unknown {
    const obj: any = {};
    if (message.black?.length) {
      obj.black = message.black.map((e) => e.toString());
    }
    if (message.white?.length) {
      obj.white = message.white.map((e) => e.toString());
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BadukBoardState>, I>>(base?: I): BadukBoardState {
    return BadukBoardState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BadukBoardState>, I>>(object: I): BadukBoardState {
    const message = createBaseBadukBoardState();
    message.black = object.black?.map((e) => e) || [];
    message.white = object.white?.map((e) => e) || [];
    return message;
  },
};

function createBasePlayerTimeInfo(): PlayerTimeInfo {
  return { mainTime: 0n, fischerTime: 0n, remainingOvertime: 0, overtime: 0n };
}

export const PlayerTimeInfo: MessageFns<PlayerTimeInfo> = {
  encode(message: PlayerTimeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mainTime !== 0n) {
      if (BigInt.asUintN(64, message.mainTime) !== message.mainTime) {
        throw new globalThis.Error("value provided for field message.mainTime of type uint64 too large");
      }
      writer.uint32(8).uint64(message.mainTime);
    }
    if (message.fischerTime !== 0n) {
      if (BigInt.asUintN(64, message.fischerTime) !== message.fischerTime) {
        throw new globalThis.Error("value provided for field message.fischerTime of type uint64 too large");
      }
      writer.uint32(16).uint64(message.fischerTime);
    }
    if (message.remainingOvertime !== 0) {
      writer.uint32(24).uint32(message.remainingOvertime);
    }
    if (message.overtime !== 0n) {
      if (BigInt.asUintN(64, message.overtime) !== message.overtime) {
        throw new globalThis.Error("value provided for field message.overtime of type uint64 too large");
      }
      writer.uint32(32).uint64(message.overtime);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerTimeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerTimeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.mainTime = reader.uint64() as bigint;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.fischerTime = reader.uint64() as bigint;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.remainingOvertime = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.overtime = reader.uint64() as bigint;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerTimeInfo {
    return {
      mainTime: isSet(object.mainTime) ? BigInt(object.mainTime) : 0n,
      fischerTime: isSet(object.fischerTime) ? BigInt(object.fischerTime) : 0n,
      remainingOvertime: isSet(object.remainingOvertime) ? globalThis.Number(object.remainingOvertime) : 0,
      overtime: isSet(object.overtime) ? BigInt(object.overtime) : 0n,
    };
  },

  toJSON(message: PlayerTimeInfo): unknown {
    const obj: any = {};
    if (message.mainTime !== 0n) {
      obj.mainTime = message.mainTime.toString();
    }
    if (message.fischerTime !== 0n) {
      obj.fischerTime = message.fischerTime.toString();
    }
    if (message.remainingOvertime !== 0) {
      obj.remainingOvertime = Math.round(message.remainingOvertime);
    }
    if (message.overtime !== 0n) {
      obj.overtime = message.overtime.toString();
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerTimeInfo>, I>>(base?: I): PlayerTimeInfo {
    return PlayerTimeInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerTimeInfo>, I>>(object: I): PlayerTimeInfo {
    const message = createBasePlayerTimeInfo();
    message.mainTime = object.mainTime ?? 0n;
    message.fischerTime = object.fischerTime ?? 0n;
    message.remainingOvertime = object.remainingOvertime ?? 0;
    message.overtime = object.overtime ?? 0n;
    return message;
  },
};

function createBaseGameState(): GameState {
  return { board: undefined, blackTime: undefined, whiteTime: undefined };
}

export const GameState: MessageFns<GameState> = {
  encode(message: GameState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.board !== undefined) {
      BadukBoardState.encode(message.board, writer.uint32(10).fork()).join();
    }
    if (message.blackTime !== undefined) {
      PlayerTimeInfo.encode(message.blackTime, writer.uint32(18).fork()).join();
    }
    if (message.whiteTime !== undefined) {
      PlayerTimeInfo.encode(message.whiteTime, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.board = BadukBoardState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blackTime = PlayerTimeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.whiteTime = PlayerTimeInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameState {
    return {
      board: isSet(object.board) ? BadukBoardState.fromJSON(object.board) : undefined,
      blackTime: isSet(object.blackTime) ? PlayerTimeInfo.fromJSON(object.blackTime) : undefined,
      whiteTime: isSet(object.whiteTime) ? PlayerTimeInfo.fromJSON(object.whiteTime) : undefined,
    };
  },

  toJSON(message: GameState): unknown {
    const obj: any = {};
    if (message.board !== undefined) {
      obj.board = BadukBoardState.toJSON(message.board);
    }
    if (message.blackTime !== undefined) {
      obj.blackTime = PlayerTimeInfo.toJSON(message.blackTime);
    }
    if (message.whiteTime !== undefined) {
      obj.whiteTime = PlayerTimeInfo.toJSON(message.whiteTime);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameState>, I>>(base?: I): GameState {
    return GameState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameState>, I>>(object: I): GameState {
    const message = createBaseGameState();
    message.board = (object.board !== undefined && object.board !== null)
      ? BadukBoardState.fromPartial(object.board)
      : undefined;
    message.blackTime = (object.blackTime !== undefined && object.blackTime !== null)
      ? PlayerTimeInfo.fromPartial(object.blackTime)
      : undefined;
    message.whiteTime = (object.whiteTime !== undefined && object.whiteTime !== null)
      ? PlayerTimeInfo.fromPartial(object.whiteTime)
      : undefined;
    return message;
  },
};

function createBaseChaksuRequest(): ChaksuRequest {
  return { coordinate: 0 };
}

export const ChaksuRequest: MessageFns<ChaksuRequest> = {
  encode(message: ChaksuRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coordinate !== 0) {
      writer.uint32(8).uint32(message.coordinate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChaksuRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChaksuRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.coordinate = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChaksuRequest {
    return { coordinate: isSet(object.coordinate) ? globalThis.Number(object.coordinate) : 0 };
  },

  toJSON(message: ChaksuRequest): unknown {
    const obj: any = {};
    if (message.coordinate !== 0) {
      obj.coordinate = Math.round(message.coordinate);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChaksuRequest>, I>>(base?: I): ChaksuRequest {
    return ChaksuRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChaksuRequest>, I>>(object: I): ChaksuRequest {
    const message = createBaseChaksuRequest();
    message.coordinate = object.coordinate ?? 0;
    return message;
  },
};

function createBaseDrawOfferRequest(): DrawOfferRequest {
  return {};
}

export const DrawOfferRequest: MessageFns<DrawOfferRequest> = {
  encode(_: DrawOfferRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrawOfferRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrawOfferRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DrawOfferRequest {
    return {};
  },

  toJSON(_: DrawOfferRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<DrawOfferRequest>, I>>(base?: I): DrawOfferRequest {
    return DrawOfferRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrawOfferRequest>, I>>(_: I): DrawOfferRequest {
    const message = createBaseDrawOfferRequest();
    return message;
  },
};

function createBaseResignRequest(): ResignRequest {
  return {};
}

export const ResignRequest: MessageFns<ResignRequest> = {
  encode(_: ResignRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResignRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResignRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResignRequest {
    return {};
  },

  toJSON(_: ResignRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResignRequest>, I>>(base?: I): ResignRequest {
    return ResignRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResignRequest>, I>>(_: I): ResignRequest {
    const message = createBaseResignRequest();
    return message;
  },
};

function createBasePassTurnRequest(): PassTurnRequest {
  return {};
}

export const PassTurnRequest: MessageFns<PassTurnRequest> = {
  encode(_: PassTurnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PassTurnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassTurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PassTurnRequest {
    return {};
  },

  toJSON(_: PassTurnRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PassTurnRequest>, I>>(base?: I): PassTurnRequest {
    return PassTurnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PassTurnRequest>, I>>(_: I): PassTurnRequest {
    const message = createBasePassTurnRequest();
    return message;
  },
};

function createBaseGameStartRequest(): GameStartRequest {
  return {};
}

export const GameStartRequest: MessageFns<GameStartRequest> = {
  encode(_: GameStartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStartRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStartRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GameStartRequest {
    return {};
  },

  toJSON(_: GameStartRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GameStartRequest>, I>>(base?: I): GameStartRequest {
    return GameStartRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameStartRequest>, I>>(_: I): GameStartRequest {
    const message = createBaseGameStartRequest();
    return message;
  },
};

function createBaseClientToServerRequest(): ClientToServerRequest {
  return {
    sessionKey: "",
    coordinate: undefined,
    resign: undefined,
    drawOffer: undefined,
    passTurn: undefined,
    gamestart: undefined,
  };
}

export const ClientToServerRequest: MessageFns<ClientToServerRequest> = {
  encode(message: ClientToServerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionKey !== "") {
      writer.uint32(10).string(message.sessionKey);
    }
    if (message.coordinate !== undefined) {
      ChaksuRequest.encode(message.coordinate, writer.uint32(802).fork()).join();
    }
    if (message.resign !== undefined) {
      ResignRequest.encode(message.resign, writer.uint32(810).fork()).join();
    }
    if (message.drawOffer !== undefined) {
      DrawOfferRequest.encode(message.drawOffer, writer.uint32(818).fork()).join();
    }
    if (message.passTurn !== undefined) {
      PassTurnRequest.encode(message.passTurn, writer.uint32(826).fork()).join();
    }
    if (message.gamestart !== undefined) {
      GameStartRequest.encode(message.gamestart, writer.uint32(834).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientToServerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientToServerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionKey = reader.string();
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.coordinate = ChaksuRequest.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.resign = ResignRequest.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.drawOffer = DrawOfferRequest.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.passTurn = PassTurnRequest.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.gamestart = GameStartRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientToServerRequest {
    return {
      sessionKey: isSet(object.sessionKey) ? globalThis.String(object.sessionKey) : "",
      coordinate: isSet(object.coordinate) ? ChaksuRequest.fromJSON(object.coordinate) : undefined,
      resign: isSet(object.resign) ? ResignRequest.fromJSON(object.resign) : undefined,
      drawOffer: isSet(object.drawOffer) ? DrawOfferRequest.fromJSON(object.drawOffer) : undefined,
      passTurn: isSet(object.passTurn) ? PassTurnRequest.fromJSON(object.passTurn) : undefined,
      gamestart: isSet(object.gamestart) ? GameStartRequest.fromJSON(object.gamestart) : undefined,
    };
  },

  toJSON(message: ClientToServerRequest): unknown {
    const obj: any = {};
    if (message.sessionKey !== "") {
      obj.sessionKey = message.sessionKey;
    }
    if (message.coordinate !== undefined) {
      obj.coordinate = ChaksuRequest.toJSON(message.coordinate);
    }
    if (message.resign !== undefined) {
      obj.resign = ResignRequest.toJSON(message.resign);
    }
    if (message.drawOffer !== undefined) {
      obj.drawOffer = DrawOfferRequest.toJSON(message.drawOffer);
    }
    if (message.passTurn !== undefined) {
      obj.passTurn = PassTurnRequest.toJSON(message.passTurn);
    }
    if (message.gamestart !== undefined) {
      obj.gamestart = GameStartRequest.toJSON(message.gamestart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ClientToServerRequest>, I>>(base?: I): ClientToServerRequest {
    return ClientToServerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ClientToServerRequest>, I>>(object: I): ClientToServerRequest {
    const message = createBaseClientToServerRequest();
    message.sessionKey = object.sessionKey ?? "";
    message.coordinate = (object.coordinate !== undefined && object.coordinate !== null)
      ? ChaksuRequest.fromPartial(object.coordinate)
      : undefined;
    message.resign = (object.resign !== undefined && object.resign !== null)
      ? ResignRequest.fromPartial(object.resign)
      : undefined;
    message.drawOffer = (object.drawOffer !== undefined && object.drawOffer !== null)
      ? DrawOfferRequest.fromPartial(object.drawOffer)
      : undefined;
    message.passTurn = (object.passTurn !== undefined && object.passTurn !== null)
      ? PassTurnRequest.fromPartial(object.passTurn)
      : undefined;
    message.gamestart = (object.gamestart !== undefined && object.gamestart !== null)
      ? GameStartRequest.fromPartial(object.gamestart)
      : undefined;
    return message;
  },
};

function createBaseChaksuResponse(): ChaksuResponse {
  return { success: false };
}

export const ChaksuResponse: MessageFns<ChaksuResponse> = {
  encode(message: ChaksuResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChaksuResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChaksuResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChaksuResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: ChaksuResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChaksuResponse>, I>>(base?: I): ChaksuResponse {
    return ChaksuResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChaksuResponse>, I>>(object: I): ChaksuResponse {
    const message = createBaseChaksuResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseResignResponse(): ResignResponse {
  return {};
}

export const ResignResponse: MessageFns<ResignResponse> = {
  encode(_: ResignResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResignResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResignResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResignResponse {
    return {};
  },

  toJSON(_: ResignResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResignResponse>, I>>(base?: I): ResignResponse {
    return ResignResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResignResponse>, I>>(_: I): ResignResponse {
    const message = createBaseResignResponse();
    return message;
  },
};

function createBaseDrawOfferResponse(): DrawOfferResponse {
  return { userName: "" };
}

export const DrawOfferResponse: MessageFns<DrawOfferResponse> = {
  encode(message: DrawOfferResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userName !== "") {
      writer.uint32(10).string(message.userName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DrawOfferResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDrawOfferResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DrawOfferResponse {
    return { userName: isSet(object.userName) ? globalThis.String(object.userName) : "" };
  },

  toJSON(message: DrawOfferResponse): unknown {
    const obj: any = {};
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DrawOfferResponse>, I>>(base?: I): DrawOfferResponse {
    return DrawOfferResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DrawOfferResponse>, I>>(object: I): DrawOfferResponse {
    const message = createBaseDrawOfferResponse();
    message.userName = object.userName ?? "";
    return message;
  },
};

function createBasePassTurnResponse(): PassTurnResponse {
  return {};
}

export const PassTurnResponse: MessageFns<PassTurnResponse> = {
  encode(_: PassTurnResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PassTurnResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePassTurnResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PassTurnResponse {
    return {};
  },

  toJSON(_: PassTurnResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PassTurnResponse>, I>>(base?: I): PassTurnResponse {
    return PassTurnResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PassTurnResponse>, I>>(_: I): PassTurnResponse {
    const message = createBasePassTurnResponse();
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { userName: "", rating: 0 };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userName !== "") {
      writer.uint32(10).string(message.userName);
    }
    if (message.rating !== 0) {
      writer.uint32(16).uint32(message.rating);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rating = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      userName: isSet(object.userName) ? globalThis.String(object.userName) : "",
      rating: isSet(object.rating) ? globalThis.Number(object.rating) : 0,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.userName !== "") {
      obj.userName = message.userName;
    }
    if (message.rating !== 0) {
      obj.rating = Math.round(message.rating);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.userName = object.userName ?? "";
    message.rating = object.rating ?? 0;
    return message;
  },
};

function createBaseGameStartResponse(): GameStartResponse {
  return {};
}

export const GameStartResponse: MessageFns<GameStartResponse> = {
  encode(_: GameStartResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameStartResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameStartResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GameStartResponse {
    return {};
  },

  toJSON(_: GameStartResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GameStartResponse>, I>>(base?: I): GameStartResponse {
    return GameStartResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameStartResponse>, I>>(_: I): GameStartResponse {
    const message = createBaseGameStartResponse();
    return message;
  },
};

function createBaseUsersInfo(): UsersInfo {
  return { black: undefined, white: undefined };
}

export const UsersInfo: MessageFns<UsersInfo> = {
  encode(message: UsersInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.black !== undefined) {
      UserInfo.encode(message.black, writer.uint32(10).fork()).join();
    }
    if (message.white !== undefined) {
      UserInfo.encode(message.white, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsersInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsersInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.black = UserInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.white = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsersInfo {
    return {
      black: isSet(object.black) ? UserInfo.fromJSON(object.black) : undefined,
      white: isSet(object.white) ? UserInfo.fromJSON(object.white) : undefined,
    };
  },

  toJSON(message: UsersInfo): unknown {
    const obj: any = {};
    if (message.black !== undefined) {
      obj.black = UserInfo.toJSON(message.black);
    }
    if (message.white !== undefined) {
      obj.white = UserInfo.toJSON(message.white);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsersInfo>, I>>(base?: I): UsersInfo {
    return UsersInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsersInfo>, I>>(object: I): UsersInfo {
    const message = createBaseUsersInfo();
    message.black = (object.black !== undefined && object.black !== null)
      ? UserInfo.fromPartial(object.black)
      : undefined;
    message.white = (object.white !== undefined && object.white !== null)
      ? UserInfo.fromPartial(object.white)
      : undefined;
    return message;
  },
};

function createBaseServerToClientResponse(): ServerToClientResponse {
  return {
    responseType: false,
    turn: 0,
    theWinner: undefined,
    gameState: undefined,
    usersInfo: undefined,
    coordinate: undefined,
    resign: undefined,
    drawOffer: undefined,
    passTurn: undefined,
    gameStart: undefined,
  };
}

export const ServerToClientResponse: MessageFns<ServerToClientResponse> = {
  encode(message: ServerToClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseType !== false) {
      writer.uint32(8).bool(message.responseType);
    }
    if (message.turn !== 0) {
      writer.uint32(16).int32(message.turn);
    }
    if (message.theWinner !== undefined) {
      writer.uint32(24).int32(message.theWinner);
    }
    if (message.gameState !== undefined) {
      GameState.encode(message.gameState, writer.uint32(34).fork()).join();
    }
    if (message.usersInfo !== undefined) {
      UsersInfo.encode(message.usersInfo, writer.uint32(42).fork()).join();
    }
    if (message.coordinate !== undefined) {
      ChaksuResponse.encode(message.coordinate, writer.uint32(802).fork()).join();
    }
    if (message.resign !== undefined) {
      ResignResponse.encode(message.resign, writer.uint32(810).fork()).join();
    }
    if (message.drawOffer !== undefined) {
      DrawOfferResponse.encode(message.drawOffer, writer.uint32(818).fork()).join();
    }
    if (message.passTurn !== undefined) {
      PassTurnResponse.encode(message.passTurn, writer.uint32(826).fork()).join();
    }
    if (message.gameStart !== undefined) {
      GameStartResponse.encode(message.gameStart, writer.uint32(834).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ServerToClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseServerToClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.responseType = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.turn = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.theWinner = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gameState = GameState.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.usersInfo = UsersInfo.decode(reader, reader.uint32());
          continue;
        }
        case 100: {
          if (tag !== 802) {
            break;
          }

          message.coordinate = ChaksuResponse.decode(reader, reader.uint32());
          continue;
        }
        case 101: {
          if (tag !== 810) {
            break;
          }

          message.resign = ResignResponse.decode(reader, reader.uint32());
          continue;
        }
        case 102: {
          if (tag !== 818) {
            break;
          }

          message.drawOffer = DrawOfferResponse.decode(reader, reader.uint32());
          continue;
        }
        case 103: {
          if (tag !== 826) {
            break;
          }

          message.passTurn = PassTurnResponse.decode(reader, reader.uint32());
          continue;
        }
        case 104: {
          if (tag !== 834) {
            break;
          }

          message.gameStart = GameStartResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ServerToClientResponse {
    return {
      responseType: isSet(object.responseType) ? globalThis.Boolean(object.responseType) : false,
      turn: isSet(object.turn) ? colorFromJSON(object.turn) : 0,
      theWinner: isSet(object.theWinner) ? colorFromJSON(object.theWinner) : undefined,
      gameState: isSet(object.gameState) ? GameState.fromJSON(object.gameState) : undefined,
      usersInfo: isSet(object.usersInfo) ? UsersInfo.fromJSON(object.usersInfo) : undefined,
      coordinate: isSet(object.coordinate) ? ChaksuResponse.fromJSON(object.coordinate) : undefined,
      resign: isSet(object.resign) ? ResignResponse.fromJSON(object.resign) : undefined,
      drawOffer: isSet(object.drawOffer) ? DrawOfferResponse.fromJSON(object.drawOffer) : undefined,
      passTurn: isSet(object.passTurn) ? PassTurnResponse.fromJSON(object.passTurn) : undefined,
      gameStart: isSet(object.gameStart) ? GameStartResponse.fromJSON(object.gameStart) : undefined,
    };
  },

  toJSON(message: ServerToClientResponse): unknown {
    const obj: any = {};
    if (message.responseType !== false) {
      obj.responseType = message.responseType;
    }
    if (message.turn !== 0) {
      obj.turn = colorToJSON(message.turn);
    }
    if (message.theWinner !== undefined) {
      obj.theWinner = colorToJSON(message.theWinner);
    }
    if (message.gameState !== undefined) {
      obj.gameState = GameState.toJSON(message.gameState);
    }
    if (message.usersInfo !== undefined) {
      obj.usersInfo = UsersInfo.toJSON(message.usersInfo);
    }
    if (message.coordinate !== undefined) {
      obj.coordinate = ChaksuResponse.toJSON(message.coordinate);
    }
    if (message.resign !== undefined) {
      obj.resign = ResignResponse.toJSON(message.resign);
    }
    if (message.drawOffer !== undefined) {
      obj.drawOffer = DrawOfferResponse.toJSON(message.drawOffer);
    }
    if (message.passTurn !== undefined) {
      obj.passTurn = PassTurnResponse.toJSON(message.passTurn);
    }
    if (message.gameStart !== undefined) {
      obj.gameStart = GameStartResponse.toJSON(message.gameStart);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ServerToClientResponse>, I>>(base?: I): ServerToClientResponse {
    return ServerToClientResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ServerToClientResponse>, I>>(object: I): ServerToClientResponse {
    const message = createBaseServerToClientResponse();
    message.responseType = object.responseType ?? false;
    message.turn = object.turn ?? 0;
    message.theWinner = object.theWinner ?? undefined;
    message.gameState = (object.gameState !== undefined && object.gameState !== null)
      ? GameState.fromPartial(object.gameState)
      : undefined;
    message.usersInfo = (object.usersInfo !== undefined && object.usersInfo !== null)
      ? UsersInfo.fromPartial(object.usersInfo)
      : undefined;
    message.coordinate = (object.coordinate !== undefined && object.coordinate !== null)
      ? ChaksuResponse.fromPartial(object.coordinate)
      : undefined;
    message.resign = (object.resign !== undefined && object.resign !== null)
      ? ResignResponse.fromPartial(object.resign)
      : undefined;
    message.drawOffer = (object.drawOffer !== undefined && object.drawOffer !== null)
      ? DrawOfferResponse.fromPartial(object.drawOffer)
      : undefined;
    message.passTurn = (object.passTurn !== undefined && object.passTurn !== null)
      ? PassTurnResponse.fromPartial(object.passTurn)
      : undefined;
    message.gameStart = (object.gameStart !== undefined && object.gameStart !== null)
      ? GameStartResponse.fromPartial(object.gameStart)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | bigint | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
